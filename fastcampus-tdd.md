# [현실 세상의 TDD: 안정감을 주는 코드 작성 방법](https://fastcampus.co.kr/dev_red_ygw)

## Intro. 좋은 코드
### 0. 엔지니어링
- 과학은 밝혀내는 것. 엔지니어링은 해결하는 것.
- Patterns always have two parts: the how and the when. Martin Fowler.

## 1부. 테스트 주도 개발 기초
### 1. 코드 기능 명세
- 지식의 흐름. 비즈니스 전문가 -> 분석가 -> 프로그래머 -> 컴퓨터
- 프로그래머에게 도메인 지식이 충분하지 않을 때 어떤 일이 발생할 수 있는가.
### 2. 테스트 기법
- 수동 테스트. 가장 온전한 코드 실행. 실행 비용이 높고 결과의 변동이 큼.
- 회귀 테스트 대상은 시간이 갈수록 늘어납니다. 수동 테스트로는 감당하기 힘듦.
- 테스트 자동화. 테스트 코드 작성 비용이 소비되지만 실행 비용이 낮고 결과의 신뢰도가 높음.
- 테스트 자동화. 테스트 코드 작성과 관리가 프로그래머 역량에 크게 영향 받음.
- 인수 테스트. 전체 시스템을 대상으로 검증. 높은 비용. 피드백 품질이 낮음.
- 단위 테스트. 시스템의 일부(하위 시스템)을 대상으로 검증. 낮은 비용. 높은 피드백 품질.
### 3. 코드 분해
- 한 번 쓰여진 코드는 필연적으로 여러 번 읽히게 됩니다.
- 커다란 문제를 나눈 작은 문제들에 대한 해법은 재사용 가능.
- 모듈. 인터페이스와 구현으로 나뉨.
### 4. 단위 테스트
- sut. System Under Test.
- 단위 테스트에서도 반복된 코드를 줄이는 방법. 하지만 테스트 자체는 개별로 유지되어야하므로, 테스트 프레임워크의 기능을 응용하자.
- 여기서는 jest의 parameterized test 기능을 사용.
### 5. 테스트 우선 개발
- 운영 코드보다 테스트 코드를 먼저 작성하는 개발 절차는 코딩의 수단보다 목적에 집중하도록 도와줍니다.
- 프로세스가 코딩에 앞선 목표 설정을 강요.
- faker를 통해 임의의 문자열을 생성, 테스트 파라미터로 사용.
### 6. 정리된 코드
- 지속적으로 코드를 정리하면 얻을 수 있는 이점.
- Re-factoring. 의미를 유지하며 코드베이스를 정리.
- 많은 프로그래머들이 의미가 유지되는 것을 확인하지 않고 고칩니다.
- 수동 테스트와 단위 테스트를 통한 의미 유지 비교.
### 7. 테스트 주도 개발
- 테스트 주도 개발은 테스트 우선 개발과 유사하지만 작은 차이가 있습니다.
- RED(테스트 실패): 실패하는 것을 확인해야 테스트가 동작함을 믿을 수 있다.
- GREEN(테스트 성공): 테스트 성공을 위한 최소한의 변경. 바로 이어서 추가 구현을 하고 싶은 유혹에 빠지면, 테스트되지 않은 코드를 추가하게 된다.
- REFACTOR(리팩터링): 코드베이스 정리. 구현 설계 개선. 인터페이스 설계를 변경해서는 안된다(테스트가 깨짐).
- TDD는 불안함을 지루함으로 바꾸는 작업.
- [켄트 벡의 설계 규칙](https://martinfowler.com/bliki/BeckDesignRules.html)
 - Passes the tests
 - Reveals intention
 - No duplication
 - Fewest elements
 - (Reveals intention과 No duplic ation은 서로 충돌할 수 있으며, 상황에 따라 선택해야 한다.)
### 8. 프로그래머 피드백
- 피드백: 코딩과 종료 사이에 있는, 원하는 결과물이었는지 확인하는 과정.
- 사용자 피드백: 가장 충격이 큰.
- Quality Assurance: 전문 인적 자원에 의한 인수 테스트.
- 프로그래머 테스트: 프로그래미가 직접 피드백 장치를 준비. 자동화된 테스트.
- 도구 피드백: 컴파일 오류, 정적 검사 등.
- "모든 테스트가 성공했습니다."
- 테스트 주도 개발의 핵심은 짧은 주기로 지속되는 피드백.
### 9. 장난감(1)
- 임의로 결정된 숫자를 플레이어가 맞추는 텍스트 콘솔 기반 게임을 만들어 봅니다.
- 순서도를 먼저 그리고, 설계를 다시 해보고. 
- 게임 모델 / 정수 생성기 인터페이스 / 게임 호스트 / 난수 정수 생성기
- 의존성을 기준으로 응용프로그램 모델 모듈과 응용프로그램 모듈로 구분. 구분은 이해했는데 이게 의존성을 기준으로 분리했다는 게 잘 이해가 안된다. 애초에 게임 호스트가 난수 정수 생성기에 의존하는지도 잘...
### 10. 장난감(2)
- 싱글 플레이어 모드를 테스트 주도 개발 방식으로 구현.
- Junit5의 @ParameterizedTest.
- TDD 실습을 볼 때마다 생각하게 되는 거지만, 늘 테스트 케이스들이 명확하고 너무 순조로운 것 아닌지... 이러이러한 테스트를 통과하면 요구사항이 충족된다는 인과가 너무 뚜렷함.
- 테스트를 추가했는데 실패하지 않는다면 검증력이 없는 것이다.
### 11. 장난감(3)
- 멀티 플레이어 모드를 테스트 주도 개발 방식으로 구현.
- 단위 테스트의 피드백을 받아가면서, 내부 구조를 많이 고쳤습니다.
- 인수 테스트. 실제로 게임을 해보면서 기능을 검증.

## 2부. 테스트 주도 개발의 깊은 곳
### 1. 인터페이스와 구현
- 협력과 계약. 대부분의 코드는 다른 코드와 협력.
- 인터페이스와 구현의 분리, 정보 숨김, 모듈화.
### 2. 환경 변화와 적응력
- 코드는 수명이 다할 때까지 많은 변화를 겪게 됩니다.
- Object-oriented(개체 지향). OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. Alan Kay.
- 개방-폐쇄 원칙(Open-closed principle). 소프트웨어 엔터티(클래스, 모듈, 함수 등)는 확장에 열리고 수정에 닫혀야 한다.
- 다형성, Composite 패턴 등을 사용.
- 적응력과 testablity. 적응력이 높은 코드는 다른 코드로부터 떼어내기 쉽고, 그만큼 testablilty가 높아진다.
### 3. 입력과 출력
- 직접 입력과 직접 출력: 퍼블릭 인터페이스를 통한 입출력. 다루기 간단함.
- 간접 입력과 간접 출력: 입력된 인터페이스를 통한 입출력. 다루기 복잡함.
- 부작용(side effect). 인터페이스 설계에 드러나지 않은 출력. 실패, 지연, 간접출력.
- 간접 입력과 간접 출력은 테스트 대역을 필요하게 만든다.
### 4. 테스트 대역
- 단위 테스트를 할 때, DOC(Depended on Component) 준비 비용이 큰 경우.
- Dummy: SUT 준비를 위해 해결되어야하는 의존성이지만, 테스트 대상은 아닌 경우 사용되는 테스트 대역.
- Stub: 간접 입력 대역. SUT에게 미리 준비된 답을 출력.
- Spy: 간접 출력 대역. SUT의 출력을 기록해놨다가 비교. 약간 애매한 느낌. 출력부도 주입 가능하도록 설계한 경우에만 사용이 가능해보임.
- Mock: SUT 내부의 행위(상호작용) 검증. 다만 다른 쪽에서는 '테스트 더블'과 동일한 의미로 Mock을 사용하기도 한다고. 그래서 RIBs의 테스트 샘플은 모든 테스트 더블을 Mock이라고 불렀나봉가.
- Fake: 의존성 계약을 준수하는 가벼운 구현체. 인메모리 데이터베이스 같은.
### 5. Mockists vs. Classicists
- 테스트 대역을 보다 조심스럽고 효과적으로 다루는 방법을 고민합니다.
- Sociable 테스트. 단위 테스트가 SUT와 의존성을 같이 구동시켜서 테스트.
- Solitary 테스트. 단위 테스트가 SUT와 의존성을 분리시켜서 테스트. 테스트 대역을 통해 의존성을 해결. 여기선 Mockist를 사용(클래스 타입을 넣어주면 Mock 객체를 리턴해줌).
- Mock의 위험. 정보 숨김 위배. 테스트가 SUT 구현에 의존. 리팩터링을 하면 Mock도 계속 영향을 받음(테스트가 깨질 가능성이 높음).
### 6. Should I test private methods
- 비공개 모듈 테스트의 작성과 사용은 공개 모듈의 구현 영역.
- 비공개 모듈 테스트는 공개 모듈의 구현을 노출시킨다. 하지 말라.
### 7. 테스트 주도 설계
- 마지막 D를 design이라고 부르는.
- 단위 테스트가 설계에 미치는 영향. 테스트가 있기 때문에 두려움 없이 개선할 수 있다.
- 단위 테스트에 의지하는 인터페이스 설계.
  - 낮은 응집에 대한 피드백을 주지 않는다.
  - 일관된 설계를 강요하지 않는다.
  - 의도 노출을 요구하지 않는다.
- 단위 테스트에 의지하는 구현 설계.
  - 단위 테스트는 책임 분산을 유도하지 않는다.
  - Mock을 과도하게 사용하게 되거나.
  - 비공개 운영 코드 테스트.
- 설계는 프로그래머의 고유하고 중요한 책임.
### 8. 테스트 주도 개발의 한계
- 어떤 경우에는 오히려 해가 될 수가 있어요.
- 불안정한 목표. 탐색적으로 목표를 찾아내야 한다면 테스트 코드 작성 비용 부담이 큼.
- 낮은 코드 적응력. (기존 코드 베이스에 대한) 적응력이 낮으면 단위 테스트하기 매우 어렵다.
- TDD를 하기 위해 받을 수 있는 지원 혹은 팀의 TDD 역량에 따라, TDD의 효과가 실제로 나타나기 시작하는 시점이 달라진다.
### 9. 인터페이스와 테스트
- 인터페이스 제공 개체 - 인터페이스 사용 개체
- API(Application Programming Interface). 테스트 자동화 비용이 낮음.
- UI(User Interface). 테스트 자동화 비용이 높음.
### 10. 인수 테스트 주도 개발
- 인수 테스트와 단위 테스트는 특징이 극명히 다르며 서로 단점을 보완해 줍니다.
- 인수 테스트. 배치가 끝난 상태에서 최종 클라이언트 관점에서 테스트. 
- 인수 테스트. UI 응용프로그램은 사용자가 최종 클라이언트.
- 인수 테스트. API 응용프로그램은 외부 시스템이 클라이언트.
- Azure의 인수 테스트 기능. 약간 체크 리스트 같은 느낌. Pass/Fail을 테스터가 직접 판정해서 입력.
- 인수 테스트를 실행하고, 실패하면 단위 테스트를 추가. TDD 사이클을 지나 단위 테스트가 성공하면, 인수 테스트를 다시 실행.
### 11. 코딩 계획
- 코딩 작업 설계.
- 코드를 쓰는 일은 프로그래머가 하위 문제에 집중하게 만듦.
- 사용자 스토리나 테스트 케이스는 목표 기술의 좋은 수단.
- 업무 가시성도 올라가고. 팀 / 업무 환경에 따라서는 여러 태스크를 병렬로 진행 가능해진다.
